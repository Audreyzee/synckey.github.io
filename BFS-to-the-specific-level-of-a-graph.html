<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>BFS遍历到图的指定层的一种方法</title>
        <link rel="stylesheet" href="http://synckey.name/theme/css/main.css" />
        <link href="http://synckey.name/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="A Pelican Blog Atom Feed" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://synckey.name/">A Pelican Blog </a></h1>
                <nav><ul>
                    <li><a href="http://synckey.name/category/digest.html">digest</a></li>
                    <li><a href="http://synckey.name/category/ielts.html">ielts</a></li>
                    <li><a href="http://synckey.name/category/life.html">life</a></li>
                    <li><a href="http://synckey.name/category/machinelearning.html">machinelearning</a></li>
                    <li class="active"><a href="http://synckey.name/category/posts.html">posts</a></li>
                    <li><a href="http://synckey.name/category/sfv.html">sfv</a></li>
                    <li><a href="http://synckey.name/category/summery.html">summery</a></li>
                    <li><a href="http://synckey.name/category/tools.html">tools</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://synckey.name/BFS-to-the-specific-level-of-a-graph.html" rel="bookmark"
           title="Permalink to BFS遍历到图的指定层的一种方法">BFS遍历到图的指定层的一种方法</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-05-10T00:00:00+08:00">
                Published: Wed 10 May 2017
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://synckey.name/author/andy.html">Andy</a>
        </address>
<p>In <a href="http://synckey.name/category/posts.html">posts</a>.</p>
<p>tags: <a href="http://synckey.name/tag/algorithm.html">algorithm</a> </p>
</footer><!-- /.post-info -->      <p><a href="https://leetcode.com/problems/word-ladder/#/description">leetcode原题</a></p>
<p>Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li>
</ol>
<p>For example,</p>
<p>Given:</p>
<p>beginWord = <code>"hit"</code></p>
<p>endWord = <code>"cog"</code></p>
<p>wordList = <code>["hot","dot","dog","lot","log","cog"]</code></p>
<p>As one shortest transformation is <code>"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"</code>,return its length <code>5</code>.</p>
<p>Note:</p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p>这个题可以用图的思路来解答，把beginWord当成是图的root节点，每个词通过一次变换的词作为这个节点的子节点，从beginWord开始遍历搜索endWord，所有的路径中最小的那些就是答案。当然，遍历的过程中要注意，这是一个有环图，要记录已经遍历过的节点。因为是路径搜索，要保存路径，所以最简单的想法是使用DFS对整个图进行搜索，最后将最短路径取出来。然而，这个方法行不通，尤其是在字典比较大的时候，树特别深，会超时。如果对整个树进行BFS也会有一样的结果，都会超时。一个优化的思路就是只对graph进行遍历，一直到endWord第一次出现的那一层终止，因为要找的是最短变换，后面的遍历没有必要。传统的BFS算法使用一个队列来保存将要遍历的节点列表，但是并不能知道当前遍历节点所在的层数。所以就用一个Map<String, Integer>来保存每个节点第一次出现的层数，endWord第一次出现的那一层，就是迭代要终止的那一层，假设为minLevel。在遍历完minLevel以后，就可以终止算法。</p>
<p>最终要输出变换路径，可以一边遍历，一边构造图的结构。这个问题是有向有环图，可以使用<code>Map&lt;String, Set&lt;String&gt;&gt; graph</code>来构造整个图。</p>
<p>最终，使用递归打印出构造出来的<code>graph</code>中所有<code>beginWord-&gt;endWord</code>之间的路径。</p>
<p>详细代码见:<a href="https://discuss.leetcode.com/topic/88859/263ms-easy-to-understand-java-solution-using-simple-BFS">263ms Easy to Understand Java Solution Using Simple BFS</a></p>
<p>这个问题还有一个简化版的问题<a href="https://leetcode.com/problems/word-ladder/#/description">Word Ladder</a>，只要求出<code>beginWord</code>和<code>endWord</code>之间最短变换的路径长度。可以用上面的解法，或者直接DFS这个图，第一次遇到<code>endWord</code>时返回路径长度即可。</p>
<h3>References</h3>
<p><a href="https://discuss.leetcode.com/topic/2857/share-two-similar-java-solution-that-accpted-by-oj/2">Share two similar Java solution that Accpted by OJ.</a></p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://synckey.name/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-55913313-1', 'auto');
    ga('send', 'pageview');
    </script>
</body>
</html>